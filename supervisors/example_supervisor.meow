construct = fun {
	-- Reliable way to get your own mod ID
	let mod_id = global.currently_executing_mod.mod_id

    -- Create the supervisor struct
    let sv = {}

	sv.display_name = mod_identifier(mod_id, "example_supervisor_name");

	sv.description = mod_identifier(mod_id, "example_supervisor_desc");



	-- This is the supervisor's sprite struct.
	-- You only actually need 2 sprites: idle, which is shown during gameplay,
	-- and preview, which is shown on the selection screen.

	-- Any states/emotions you don't supply use the idle sprite.
	
	sv.sprites = {
		idle_neutral : mod_get_sprite("spr_gambler_tony_idle_neutral"),
		preview : mod_get_sprite("spr_gambler_tony_preview"),

		-- you can also include more states/emotions here. For example:
		-- angry : mod_get_sprite("spr_gambler_tony_angry"),
		-- would have supplied the angry sprite, if I had made one...

		-- List of states:
		-- angry
		-- evil
		-- head_swivel
		-- scream
		-- idle_happy
		-- idle_sad
		-- idle_weird

		-- Tutorial only states:
		-- talk
		-- sad

		-- Unused states:
		-- happy
		-- idle_grimace
		


	}

	-- Supervisor selection name color
	-- Catspeak supports colors in this format: #RRGGBB
	sv.name_color = #000000

	-- Cost in stars
	-- I'd recommend 0
	sv.cost = 0


	sv.on_create = fun {
		-- Runs when the run begins
		-- Create a functional object that will make it so we can only reroll when we have enough money, and subtracts money when we reroll

		-- Disable Pickle Rat
		instance_find(obj_ItemMGMT, 0).InItemPool[50] = 0

		let object_depth = instance_find(obj_ItemMGMT, 0).depth - 4 -- Create the object 1 depth above all the reroll buttons
		reroll_object = instance_create_depth(0, 0, object_depth, obj_functional_object, {
			on_create : fun {
				-- There are 3 types of reroll buttons: shop, cafe, and black market. We need to check for the existence of any of them.
				self.button_objects = [obj_RerollBtn, obj_RerollBtnCafe, obj_RerollBtnBM]

				-- For the regular shop, we want to track the cost for cafe and normal reroll independently.
				self.costs = [2, 2, 2]

			},
			on_step : fun {
				
				let i = array_length(self.button_objects)
				-- no for loops in catspeak, we must use while
				while (i > 0) {
					i -= 1

					let instance = instance_find(self.button_objects[i], 0)
					if (instance == noone) {
						continue
					}

					-- Button exists. We have its instance.
					if (global.Money >= self.costs[i]) {
						-- We can reroll.
						if (instance.RerollLimit == -1) {
							-- If we disabled reroll, renable
							instance.RerollLimit = 1
						}

						-- If button was pressed, reroll limit will be 0
						-- we only check once reroll limit hits 0
						if (instance.RerollLimit == 0) {
							instance.RerollLimit = 1
							scr_PayMoney(self.costs[i])
							self.costs[i] += 1
						}
					}
					else {
						-- Disable
						instance.RerollLimit = -1
					}
				}
				

				-- Quite conveniently, when entering or exiting the shop or black market, ItemMGMT's alarm 0 event becomes 15. Perfect time to reset costs.
				with (obj_ItemMGMT) {
					if (alarm_get(0) == 15) {
						other.costs[0] = 2
						other.costs[1] = 2
						other.costs[2] = 2
					}
				}

			},
			on_draw : fun {
				let i = array_length(self.button_objects)
				-- no for loops in catspeak, we must use while
				while (i > 0) {
					i -= 1
					let instance = instance_find(self.button_objects[i], 0)
					if (instance == noone) {
						continue
					}
					-- Draw price
					if (global.Money >= self.costs[i]) {
						draw_set_color(c_white)
					}
					else {
						draw_set_color(0x6666FF)
					}
					draw_set_halign(fa_center)
					draw_set_valign(fa_middle)
					let price_length = string_width(self.costs[i])
					draw_text(instance.x, (instance.y + 45), self.costs[i])
					draw_sprite(spr_GoldCoinSm, 0, (instance.x + price_length + 10), (instance.y + 45))
				}

			},
			-- This name gets printed if this object errors
			name : "gambler_tony_reroll_object",


		})
	}

	sv.on_destroy = fun {
		-- We created reroll_object in a global scope, so we can still access it here
		instance_destroy(reroll_object)
	}




	-- Return our supervisor struct so it can be registered in supervisors.meow
	return sv;
}